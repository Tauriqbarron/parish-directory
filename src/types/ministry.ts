// =============================================================================
// MINISTRY TYPES
// =============================================================================
// Ministries are NEW to this project — they represent parish groups like
// Lectors, Eucharistic Ministers, Choir, Youth Group, etc.
// This data is stored by THIS app's API routes, not the FastAPI backend.
//
// LEARNING GOALS:
// - Enum vs union types (and when to use each)
// - Generic interfaces for CRUD operations
// - Extending interfaces
// =============================================================================

import { PersonSummary } from "./person";

// TODO: Define a union type called 'MinistryStatus'
// - 'active' | 'inactive' | 'seasonal'
// - Seasonal means it only runs part of the year (e.g. Christmas Choir)
export type MinistryStatus = "active" | "inactive" | "seasonal";

// TODO: Define a union type called 'MemberRole'
// - 'leader' | 'coordinator' | 'member'
export type MemberRole = "leader" | "coordinator" | "member";

// TODO: Define an interface called 'Ministry'
// - id: string — UUID generated by database
// - name: string — e.g. "Eucharistic Ministers", "Youth Group"
// - description: string (optional)
// - status: MinistryStatus
// - meetingDay: string (optional) — e.g. "Wednesday"
// - meetingTime: string (optional) — e.g. "7:00 PM"
// - meetingLocation: string (optional) — e.g. "Parish Hall"
// - maxMembers: number (optional) — null means unlimited
// - createdAt: string
// - updatedAt: string
export interface Ministry {
  id: string;
  name: string;
  description?: string;
  status: MinistryStatus;
  meetingDay?: string;
  meetingTime?: string;
  meetingLocation?: string;
  maxMembers?: number | null;
  createdAt: string;
  updatedAt: string;
}

// TODO: Define an interface called 'MinistryMember'
// - id: string — UUID
// - ministryId: string — FK to Ministry
// - personId: number — FK to Person in Parish Database
// - role: MemberRole
// - joinedAt: string — ISO date when they joined the ministry
// - person: PersonSummary (optional) — populated when fetching with details
//
// LEARNING: personId is a number (from PostgreSQL Parish Database) while
// ministryId is a string UUID (from this app). Notice how different systems
// can use different ID strategies and your types reflect that.
export interface MinistryMember {
  id: string;
  ministryId: string;
  personId: number;
  role: MemberRole;
  joinedAt: string;
  person?: PersonSummary;
}

// TODO: Define an interface called 'MinistryWithMembers'
// - Extends Ministry using 'extends' keyword (not intersection this time)
// - Add: members: MinistryMember[]
// - Add: memberCount: number
//
// LEARNING: 'extends' is the OOP way to compose interfaces. Compare this
// with the intersection approach in household.ts. Both work, but 'extends'
// gives better error messages and is more readable for clear hierarchies.

// TODO: Define an interface called 'CreateMinistryInput'
// - Use Omit<Ministry, 'id' | 'createdAt' | 'updatedAt'>
// - This is what the POST /api/ministries endpoint accepts

// TODO: Define an interface called 'UpdateMinistryInput'
// - Use Partial<CreateMinistryInput>
// - LEARNING: Partial<T> makes ALL properties optional. This is perfect
//   for PATCH/PUT operations where you only send changed fields.
//   Partial<Omit<...>> is a very common pattern for update DTOs.
